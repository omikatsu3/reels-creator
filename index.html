<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reels Video Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans JP', sans-serif; background-color: #1a1a1a; color: #f0f0f0; }
        .card { background-color: #2a2a2a; border: 1px solid #444; }
        .btn-primary { background-color: #007bff; color: white; transition: background-color 0.3s; }
        .btn-primary:hover:not(:disabled) { background-color: #0056b3; }
        .btn-primary:disabled { background-color: #004085; cursor: not-allowed; opacity: 0.6; }
        .btn-secondary { background-color: #4a4a4a; color: white; transition: background-color: 0.3s; }
        .btn-secondary:hover:not(:disabled) { background-color: #6a6a6a; }
        .btn-secondary:disabled { cursor: not-allowed; opacity: 0.5; }
        .btn-danger { background-color: #dc3545; transition: background-color: 0.3s; }
        .btn-danger:hover { background-color: #c82333; }
        .file-input, .subtitle-input, .duration-input { background-color: #3a3a3a; border: 1px solid #555; color: #f0f0f0; }
        .progress-bar-bg { background-color: #3a3a3a; }
        .progress-bar-fg { background-color: #007bff; }
        .hidden { display: none; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-2xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold mb-2">リール動画クリエイター</h1>
            <p class="text-gray-400">画像や動画を組み合わせて縦長動画を作成します。</p>
        </header>

        <main>
            <section id="clips-section" class="space-y-4 mb-6">
                <h2 class="text-xl font-semibold border-b-2 border-gray-600 pb-2">1. クリップの編集</h2>
                <div id="assets-container" class="space-y-4">
                    <!-- クリップはここに動的に追加されます -->
                </div>
                <button id="add-asset-btn" class="w-full btn-secondary p-3 rounded-lg flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg>
                    クリップを追加 (最大5つ)
                </button>
            </section>

            <section class="mb-6 card p-4 rounded-lg">
                <h2 class="text-xl font-semibold mb-3">2. BGMの設定 (任意)</h2>
                <input type="file" id="bgm-file" accept="audio/mp3,audio/wav,audio/m4a" class="file-input w-full text-sm rounded-lg cursor-pointer focus:outline-none">
            </section>

            <section>
                <button id="generate-btn" class="w-full btn-primary p-4 rounded-lg text-lg font-bold flex items-center justify-center gap-3" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L9 9.414V13a1 1 0 102 0V9.414l1.293 1.293a1 1 0 001.414-1.414z" clip-rule="evenodd" /></svg>
                    動画を生成する
                </button>
            </section>

            <section id="status-container" class="mt-6 hidden">
                <div class="card p-4 rounded-lg text-center">
                    <p id="status-message" class="mb-3">処理を開始しています...</p>
                    <div class="progress-bar-bg w-full rounded-full h-4">
                        <div id="progress-bar" class="progress-bar-fg h-4 rounded-full" style="width: 0%;"></div>
                    </div>
                </div>
            </section>

            <section id="result-container" class="mt-6 hidden">
                 <div class="card p-4 rounded-lg">
                    <h2 class="text-xl font-semibold mb-3 text-center">動画が完成しました！</h2>
                    <video id="result-video" class="w-full rounded-lg mb-4" controls></video>
                    <a id="download-link" class="w-full block text-center btn-primary p-3 rounded-lg font-bold">動画をダウンロード</a>
                </div>
            </section>
        </main>
    </div>

    <!-- JavaScript モジュール -->
    <script type="module">
        // mp4-muxerをCDNからインポート
        // 古いURLから、現在有効なURLに修正しました。
        import { Muxer, ArrayBufferTarget } from 'https://unpkg.com/mp4-muxer/build/mp4-muxer.mjs';

        // アプリケーション全体を初期化する関数
        // DOMが完全に読み込まれてから実行することで、要素が見つからないエラーを防ぐ
        function initializeApp() {
            console.log("initializeApp: アプリケーションの初期化を開始します。");

            // --- DOM要素の取得 ---
            const assetsContainer = document.getElementById('assets-container');
            const addAssetBtn = document.getElementById('add-asset-btn');
            const bgmFileInput = document.getElementById('bgm-file');
            const generateBtn = document.getElementById('generate-btn');
            const statusContainer = document.getElementById('status-container');
            const statusMessage = document.getElementById('status-message');
            const progressBar = document.getElementById('progress-bar');
            const resultContainer = document.getElementById('result-container');
            const resultVideo = document.getElementById('result-video');
            const downloadLink = document.getElementById('download-link');
            
            // --- 状態管理 ---
            let assets = [];
            const MAX_ASSETS = 5;

            // --- 動画設定 ---
            const VIDEO_WIDTH = 720;
            const VIDEO_HEIGHT = 1280;
            const FPS = 30;

            // --- UI更新ロジック ---

            function renderAssets() {
                console.log("renderAssets: クリップのUIを再描画します。", assets);
                assetsContainer.innerHTML = '';
                assets.forEach((asset, index) => {
                    const assetEl = document.createElement('div');
                    assetEl.className = 'card p-4 rounded-lg flex flex-col md:flex-row gap-4 items-center';
                    assetEl.innerHTML = `
                        <div class="flex-shrink-0 w-24 h-40 bg-black rounded-md flex items-center justify-center overflow-hidden">
                            ${asset.previewUrl ? 
                                (asset.type === 'video' ? `<video src="${asset.previewUrl}" class="w-full h-full object-cover" muted loop autoplay playsinline></video>` : `<img src="${asset.previewUrl}" class="w-full h-full object-cover">`)
                                : '<span class="text-gray-500 text-xs">ファイルを選択</span>'
                            }
                        </div>
                        <div class="flex-grow w-full">
                            <label class="block text-sm font-medium text-gray-300 mb-2">クリップ ${index + 1}</label>
                            <input type="file" data-index="${index}" accept="image/*,video/mp4,video/webm,video/quicktime" class="file-input w-full text-sm rounded-lg cursor-pointer focus:outline-none mb-2">
                            <input type="text" data-index="${index}" value="${asset.subtitle}" placeholder="字幕 (任意)" class="subtitle-input w-full p-2 rounded-md mb-2">
                            ${asset.type !== 'video' ? 
                                `<div class="flex items-center gap-2">
                                    <label class="text-sm">表示時間(秒):</label>
                                    <input type="number" data-index="${index}" value="${asset.duration}" min="0.1" step="0.1" class="duration-input w-20 p-2 rounded-md">
                                </div>` : 
                                `<div class="text-sm text-gray-400">動画の長さ: ${asset.duration ? asset.duration.toFixed(1) : '計算中...'}秒</div>`
                            }
                        </div>
                        <button data-index="${index}" class="remove-btn flex-shrink-0 p-2 rounded-full btn-danger text-white">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
                        </button>
                    `;
                    assetsContainer.appendChild(assetEl);
                });
                updateButtonsState();
            }

            function updateButtonsState() {
                const allFilesSelected = assets.length > 0 && assets.every(a => a.file);
                addAssetBtn.disabled = assets.length >= MAX_ASSETS;
                addAssetBtn.classList.toggle('opacity-50', addAssetBtn.disabled);
                generateBtn.disabled = !allFilesSelected;
            }
            
            // --- クリップ管理関数 ---

            function addNewClip() {
                if (assets.length < MAX_ASSETS) {
                    console.log("addNewClip: 新しいクリップを追加します。");
                    assets.push({ id: Date.now(), file: null, type: 'image', subtitle: '', duration: 3, previewUrl: null });
                    renderAssets();
                } else {
                    console.warn("addNewClip: クリップが最大数に達しています。");
                }
            }

            function removeClip(index) {
                console.log(`removeClip: クリップ ${index} を削除します。`);
                // メモリリークを防ぐためにプレビューURLを解放
                if (assets[index].previewUrl) {
                    URL.revokeObjectURL(assets[index].previewUrl);
                }
                assets.splice(index, 1);

                // もし全てのクリップが削除されたら、新しい空のクリップを1つ追加する
                if (assets.length === 0) {
                    addNewClip();
                } else {
                    renderAssets();
                }
            }

            async function updateClipFile(index, file) {
                const asset = assets[index];
                asset.file = file;
                asset.type = file.type.startsWith('video') ? 'video' : 'image';
                
                if (asset.previewUrl) URL.revokeObjectURL(asset.previewUrl);
                asset.previewUrl = URL.createObjectURL(file);

                if (asset.type === 'video') {
                    asset.duration = null; // 計算中であることを示す
                    renderAssets(); // 先にプレビューを表示
                    asset.duration = await getVideoDuration(file);
                }
                renderAssets();
            }

            // --- イベントリスナー ---
            
            addAssetBtn.addEventListener('click', addNewClip);

            assetsContainer.addEventListener('change', async (e) => {
                const index = parseInt(e.target.dataset.index);
                if (isNaN(index)) return;

                if (e.target.classList.contains('file-input')) {
                    const file = e.target.files[0];
                    if (file) {
                        await updateClipFile(index, file);
                    }
                } else if (e.target.classList.contains('subtitle-input')) {
                    assets[index].subtitle = e.target.value;
                } else if (e.target.classList.contains('duration-input')) {
                    assets[index].duration = parseFloat(e.target.value) || 3;
                }
            });

            assetsContainer.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-btn');
                if (removeBtn) {
                    const index = parseInt(removeBtn.dataset.index);
                    if (!isNaN(index)) {
                        removeClip(index);
                    }
                }
            });

            generateBtn.addEventListener('click', generateVideo);
            
            // --- 補助関数 ---
            async function getVideoDuration(file) {
                return new Promise((resolve) => {
                    const video = document.createElement('video');
                    video.preload = 'metadata';
                    video.onloadedmetadata = () => {
                        URL.revokeObjectURL(video.src);
                        resolve(video.duration);
                    };
                    video.src = URL.createObjectURL(file);
                });
            }
            
            function updateProgress(message, percentage) {
                statusMessage.textContent = message;
                progressBar.style.width = `${percentage}%`;
            }

            // --- メインの動画生成ロジック (省略 - 変更なし) ---
            async function generateVideo() {
                if (!('VideoEncoder' in window)) {
                    statusMessage.textContent = 'エラー: お使いのブラウザはこのツールをサポートしていません。';
                    statusContainer.classList.remove('hidden');
                    return;
                }
                
                generateBtn.disabled = true;
                generateBtn.textContent = '処理中...';
                statusContainer.classList.remove('hidden');
                resultContainer.classList.add('hidden');
                updateProgress('準備中...', 0);

                try {
                    let totalDuration = assets.reduce((sum, a) => sum + a.duration, 0);
                    let muxer = new Muxer({
                        target: new ArrayBufferTarget(),
                        video: { codec: 'avc', width: VIDEO_WIDTH, height: VIDEO_HEIGHT },
                        audio: bgmFileInput.files[0] ? { codec: 'aac', sampleRate: 44100, numberOfChannels: 2 } : undefined,
                        fastStart: 'fragmented'
                    });

                    let videoEncoder = new VideoEncoder({
                        output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
                        error: (e) => console.error(e)
                    });
                    videoEncoder.configure({
                        codec: 'avc1.42001f',
                        width: VIDEO_WIDTH,
                        height: VIDEO_HEIGHT,
                        bitrate: 5_000_000,
                        framerate: FPS
                    });
                    
                    let audioEncoder, audioContext, bgmBuffer;
                    if (bgmFileInput.files[0]) {
                        updateProgress('BGMをデコード中...', 5);
                        audioContext = new AudioContext({ sampleRate: 44100 });
                        const bgmArrayBuffer = await bgmFileInput.files[0].arrayBuffer();
                        bgmBuffer = await audioContext.decodeAudioData(bgmArrayBuffer);
                        audioEncoder = new AudioEncoder({
                            output: (chunk, meta) => muxer.addAudioChunk(chunk, meta),
                            error: (e) => console.error(e)
                        });
                        audioEncoder.configure({ codec: 'mp4a.40.2', sampleRate: 44100, numberOfChannels: 2, bitrate: 128_000 });
                    }
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = VIDEO_WIDTH;
                    canvas.height = VIDEO_HEIGHT;
                    const ctx = canvas.getContext('2d');

                    updateProgress('クリップを準備中...', 10);
                    const assetData = await Promise.all(assets.map(async (asset) => {
                        if (asset.type === 'video') {
                           const videoEl = document.createElement('video');
                           videoEl.src = URL.createObjectURL(asset.file);
                           videoEl.muted = true;
                           await new Promise((resolve, reject) => { videoEl.onloadedmetadata = resolve; videoEl.onerror = reject; });
                           return { type: 'video', element: videoEl };
                        } else {
                            const bitmap = await createImageBitmap(asset.file);
                            return { type: 'image', element: bitmap };
                        }
                    }));

                    let frameCounter = 0;
                    let elapsed = 0;
                    updateProgress('フレームをレンダリング中...', 15);

                    for (let assetIndex = 0; assetIndex < assets.length; assetIndex++) {
                        const asset = assets[assetIndex];
                        const data = assetData[assetIndex];
                        const duration = asset.duration;
                        const totalFramesForAsset = Math.round(duration * FPS);

                        for (let frameIndex = 0; frameIndex < totalFramesForAsset; frameIndex++) {
                            const timeInCurrentAsset = frameIndex / FPS;
                            const timestamp = (frameCounter * 1_000_000) / FPS;

                            ctx.fillStyle = 'black';
                            ctx.fillRect(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
                            
                            const el = data.element;
                            const elAspect = (el.videoWidth || el.width) / (el.videoHeight || el.height);
                            const canvasAspect = VIDEO_WIDTH / VIDEO_HEIGHT;
                            let dw, dh, dx, dy;
                            if (elAspect > canvasAspect) {
                                dh = VIDEO_HEIGHT; dw = dh * elAspect; dx = (VIDEO_WIDTH - dw) / 2; dy = 0;
                            } else {
                                dw = VIDEO_WIDTH; dh = dw / elAspect; dy = (VIDEO_HEIGHT - dh) / 2; dx = 0;
                            }

                            if (data.type === 'video') {
                                el.currentTime = timeInCurrentAsset;
                                await new Promise(r => { el.onseeked = r; if(el.readyState >= 3) r(); });
                                ctx.drawImage(el, dx, dy, dw, dh);
                            } else {
                                ctx.drawImage(el, dx, dy, dw, dh);
                            }

                            if (asset.subtitle) {
                                ctx.font = 'bold 52px "Noto Sans JP", sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillStyle = 'white';
                                ctx.shadowColor = 'black';
                                ctx.shadowBlur = 10;
                                ctx.fillText(asset.subtitle, VIDEO_WIDTH / 2, VIDEO_HEIGHT * 0.8);
                            }
                            
                            const frame = new VideoFrame(canvas, { timestamp });
                            videoEncoder.encode(frame);
                            frame.close();
                            
                            if (audioEncoder && bgmBuffer) {
                                const audioTimestamp = (elapsed + timeInCurrentAsset) * 1_000_000;
                                const audioStart = Math.floor((elapsed + timeInCurrentAsset) * bgmBuffer.sampleRate);
                                const audioEnd = Math.floor((elapsed + timeInCurrentAsset + 1/FPS) * bgmBuffer.sampleRate);
                                const frameSamples = audioEnd - audioStart;
                                if (frameSamples > 0) {
                                    const audioData = new Float32Array(frameSamples * bgmBuffer.numberOfChannels);
                                    for (let c = 0; c < bgmBuffer.numberOfChannels; c++) {
                                        const channelData = bgmBuffer.getChannelData(c);
                                        for (let i = 0; i < frameSamples; i++) {
                                            audioData[i * bgmBuffer.numberOfChannels + c] = channelData[(audioStart + i) % channelData.length];
                                        }
                                    }
                                    const audioFrame = new AudioData({
                                        format: 'f32',
                                        sampleRate: bgmBuffer.sampleRate,
                                        numberOfFrames: frameSamples,
                                        numberOfChannels: bgmBuffer.numberOfChannels,
                                        timestamp: timestamp,
                                        data: audioData,
                                    });
                                    audioEncoder.encode(audioFrame);
                                    audioFrame.close();
                                }
                            }

                            frameCounter++;
                        }
                        elapsed += duration;
                        updateProgress(`レンダリング中...`, 15 + 80 * (elapsed / totalDuration));
                    }
                    
                    updateProgress('最終処理中...', 95);
                    await videoEncoder.flush();
                    if (audioEncoder) await audioEncoder.flush();
                    muxer.finalize();
                    
                    const { buffer } = muxer.target;
                    const blob = new Blob([buffer], { type: 'video/mp4' });
                    const url = URL.createObjectURL(blob);

                    resultVideo.src = url;
                    downloadLink.href = url;
                    downloadLink.download = `reels-video-${Date.now()}.mp4`;

                    statusContainer.classList.add('hidden');
                    resultContainer.classList.remove('hidden');

                } catch (err) {
                    console.error("動画生成中にエラーが発生しました:", err);
                    statusMessage.textContent = `エラーが発生しました: ${err.message}`;
                    progressBar.style.backgroundColor = 'red';
                } finally {
                    generateBtn.disabled = false;
                    generateBtn.textContent = '動画を生成する';
                }
            }

            // --- アプリケーションの実行開始 ---
            // 最初に空のクリップを1つ追加してUIを表示
            addNewClip();
        }

        // DOMの読み込みが完了したら、initializeApp関数を実行する
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            // すでに読み込みが完了している場合
            initializeApp();
        }

    </script>
</body>
</html>

