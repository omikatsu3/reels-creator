<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reels Video Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans JP', sans-serif; background-color: #1a1a1a; color: #f0f0f0; }
        .card { background-color: #2a2a2a; border: 1px solid #444; }
        .btn-primary { background-color: #007bff; color: white; transition: background-color: 0.3s; }
        .btn-primary:hover:not(:disabled) { background-color: #0056b3; }
        .btn-primary:disabled { background-color: #004085; cursor: not-allowed; opacity: 0.6; }
        .btn-secondary { background-color: #4a4a4a; color: white; transition: background-color: 0.3s; }
        .btn-secondary:hover:not(:disabled) { background-color: #6a6a6a; }
        .btn-secondary:disabled { cursor: not-allowed; opacity: 0.5; }
        .btn-danger { background-color: #dc3545; transition: background-color: 0.3s; }
        .btn-danger:hover { background-color: #c82333; }
        .file-input, .subtitle-input, .duration-input { background-color: #3a3a3a; border: 1px solid #555; color: #f0f0f0; }
        .progress-bar-bg { background-color: #3a3a3a; }
        .progress-bar-fg { background-color: #007bff; }
        .hidden { display: none; }
        .notice { background-color: #2c3e50; border-left: 4px solid #3498db; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-2xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold mb-2">リール動画クリエイター</h1>
            <p class="text-gray-400">画像や動画を組み合わせて縦長動画を作成します。</p>
        </header>

        <section class="notice p-4 rounded-lg mb-8 text-sm">
            <h3 class="font-bold mb-2 text-base">【ご利用上の注意】</h3>
            <ul class="list-disc list-inside space-y-1 text-gray-300">
                <li>対応ファイル: [動画] MP4, WEBM, MOV等 [画像] JPG, PNG, GIF [BGM] MP3, WAV, M4A</li>
                <li>WebM形式の動画ファイルもご利用いただけます。</li>
                <li>ファイルサイズが大きい素材 (特にBGM) を使用すると、メモリ不足でブラウザが停止することがあります。</li>
                <li>すべての処理はお使いのデバイス上で行われます。生成された動画はご自身で管理してください。</li>
            </ul>
        </section>

        <main>
            <section id="clips-section" class="space-y-4 mb-6">
                <h2 class="text-xl font-semibold border-b-2 border-gray-600 pb-2">1. クリップの編集</h2>
                <div id="assets-container" class="space-y-4">
                    <!-- クリップはここに動的に追加されます -->
                </div>
                <button id="add-asset-btn" class="w-full btn-secondary p-3 rounded-lg flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg>
                    クリップを追加 (最大5つ)
                </button>
            </section>

            <section class="mb-6 card p-4 rounded-lg">
                <h2 class="text-xl font-semibold mb-3">2. BGMの設定 (任意)</h2>
                <input type="file" id="bgm-file" accept="audio/mp3,audio/wav,audio/m4a" class="file-input w-full text-sm rounded-lg cursor-pointer focus:outline-none">
            </section>

            <section>
                <button id="generate-btn" class="w-full btn-primary p-4 rounded-lg text-lg font-bold flex items-center justify-center gap-3" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L9 9.414V13a1 1 0 102 0V9.414l1.293 1.293a1 1 0 001.414-1.414z" clip-rule="evenodd" /></svg>
                    動画を生成する
                </button>
            </section>

            <section id="status-container" class="mt-6 hidden">
                <div class="card p-4 rounded-lg text-center">
                    <p id="status-message" class="mb-3">処理を開始しています...</p>
                    <div class="progress-bar-bg w-full rounded-full h-4">
                        <div id="progress-bar" class="progress-bar-fg h-4 rounded-full" style="width: 0%;"></div>
                    </div>
                    <button id="cancel-btn" class="mt-4 btn-danger px-4 py-2 rounded-lg text-sm">生成を中止</button>
                </div>
            </section>

            <section id="result-container" class="mt-6 hidden">
                 <div class="card p-4 rounded-lg">
                    <h2 class="text-xl font-semibold mb-3 text-center">動画が完成しました！</h2>
                    <video id="result-video" class="w-full rounded-lg mb-4" controls></video>
                    <a id="download-link" class="w-full block text-center btn-primary p-3 rounded-lg font-bold">動画をダウンロード</a>
                </div>
            </section>
        </main>
    </div>

    <!-- JavaScript モジュール -->
    <script type="module">
        // mp4-muxerをCDNからインポート
        import { Muxer, ArrayBufferTarget } from 'https://unpkg.com/mp4-muxer/build/mp4-muxer.mjs';

        function initializeApp() {
            console.log("initializeApp: アプリケーションの初期化を開始します。");

            const assetsContainer = document.getElementById('assets-container');
            const addAssetBtn = document.getElementById('add-asset-btn');
            const bgmFileInput = document.getElementById('bgm-file');
            const generateBtn = document.getElementById('generate-btn');
            const statusContainer = document.getElementById('status-container');
            const statusMessage = document.getElementById('status-message');
            const progressBar = document.getElementById('progress-bar');
            const cancelBtn = document.getElementById('cancel-btn');
            const resultContainer = document.getElementById('result-container');
            const resultVideo = document.getElementById('result-video');
            const downloadLink = document.getElementById('download-link');
            
            let assets = [];
            let cancellationController;
            const MAX_ASSETS = 5;
            const VIDEO_WIDTH = 720;
            const VIDEO_HEIGHT = 1280;
            const FPS = 30;

            function renderAssets() {
                assetsContainer.innerHTML = '';
                assets.forEach((asset, index) => {
                    const settings = asset.subtitleSettings;
                    const assetEl = document.createElement('div');
                    assetEl.className = 'card p-4 rounded-lg flex flex-col md:flex-row gap-4 items-start';
                    assetEl.innerHTML = `
                        <div class="flex-shrink-0 w-24 h-40 bg-black rounded-md flex items-center justify-center overflow-hidden">
                            ${asset.previewUrl ? 
                                (asset.type === 'video' ? `<video src="${asset.previewUrl}" class="w-full h-full object-cover" muted loop autoplay playsinline></video>` : `<img src="${asset.previewUrl}" class="w-full h-full object-cover">`)
                                : '<span class="text-gray-500 text-xs">ファイルを選択</span>'
                            }
                        </div>
                        <div class="flex-grow w-full space-y-3">
                            <div>
                                <label class="block text-sm font-medium text-gray-300 mb-1">クリップ ${index + 1} のファイル</label>
                                <input type="file" data-index="${index}" accept="image/*,video/mp4,video/webm,video/quicktime" class="file-input w-full text-sm rounded-lg cursor-pointer focus:outline-none">
                            </div>
                             ${asset.type !== 'video' ? 
                                `<div class="flex items-center gap-2">
                                    <label class="text-sm">表示時間(秒):</label>
                                    <input type="number" data-index="${index}" value="${asset.duration}" min="0.1" step="0.1" class="duration-input w-20 p-2 rounded-md">
                                </div>` : 
                                `<div class="text-sm text-gray-400">動画の長さ: ${asset.duration ? asset.duration.toFixed(1) : '計算中...'}秒</div>`
                            }
                            <div class="border-t border-gray-600 pt-3 space-y-3">
                                <input type="text" data-index="${index}" value="${asset.subtitle}" placeholder="字幕 (任意)" class="subtitle-input w-full p-2 rounded-md">
                                <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 text-sm">
                                    <div>
                                        <label class="block mb-1">文字サイズ: <span class="font-mono">${settings.fontSize}px</span></label>
                                        <input type="range" data-index="${index}" value="${settings.fontSize}" min="20" max="100" class="font-size-input w-full">
                                    </div>
                                    <div>
                                        <label class="block mb-1">縦の位置: <span class="font-mono">${settings.position}%</span></label>
                                        <input type="range" data-index="${index}" value="${settings.position}" min="10" max="90" class="position-input w-full">
                                    </div>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="checkbox" id="bg-checkbox-${index}" data-index="${index}" class="bg-checkbox" ${settings.background ? 'checked' : ''}>
                                    <label for="bg-checkbox-${index}">背景に帯を追加</label>
                                </div>
                            </div>
                        </div>
                        <button data-index="${index}" class="remove-btn flex-shrink-0 p-2 rounded-full btn-danger text-white">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
                        </button>
                    `;
                    assetsContainer.appendChild(assetEl);
                });
                updateButtonsState();
            }

            function updateButtonsState() {
                const allFilesSelected = assets.length > 0 && assets.every(a => a.file);
                addAssetBtn.disabled = assets.length >= MAX_ASSETS;
                addAssetBtn.classList.toggle('opacity-50', addAssetBtn.disabled);
                generateBtn.disabled = !allFilesSelected;
            }

            function addNewClip() {
                if (assets.length < MAX_ASSETS) {
                    assets.push({ 
                        id: Date.now(), file: null, type: 'image', 
                        subtitle: '', 
                        subtitleSettings: { fontSize: 52, position: 80, background: false },
                        duration: 3, previewUrl: null 
                    });
                    renderAssets();
                }
            }

            function removeClip(index) {
                if (assets[index].previewUrl) URL.revokeObjectURL(assets[index].previewUrl);
                assets.splice(index, 1);
                if (assets.length === 0) addNewClip();
                else renderAssets();
            }

            async function updateClipFile(index, file) {
                const asset = assets[index];
                asset.file = file;
                asset.type = file.type.startsWith('video') ? 'video' : 'image';
                if (asset.previewUrl) URL.revokeObjectURL(asset.previewUrl);
                asset.previewUrl = URL.createObjectURL(file);
                if (asset.type === 'video') {
                    asset.duration = null;
                    renderAssets();
                    asset.duration = await getVideoDuration(file);
                }
                renderAssets();
            }

            addAssetBtn.addEventListener('click', addNewClip);

            assetsContainer.addEventListener('input', (e) => {
                const index = parseInt(e.target.dataset.index);
                if (isNaN(index)) return;

                if (e.target.classList.contains('subtitle-input')) {
                    assets[index].subtitle = e.target.value;
                } else if (e.target.classList.contains('font-size-input')) {
                    assets[index].subtitleSettings.fontSize = parseInt(e.target.value);
                    renderAssets();
                } else if (e.target.classList.contains('position-input')) {
                    assets[index].subtitleSettings.position = parseInt(e.target.value);
                    renderAssets();
                }
            });

            assetsContainer.addEventListener('change', async (e) => {
                const index = parseInt(e.target.dataset.index);
                if (isNaN(index)) return;

                if (e.target.classList.contains('file-input')) {
                    const file = e.target.files[0];
                    if (file) await updateClipFile(index, file);
                } else if (e.target.classList.contains('duration-input')) {
                    assets[index].duration = parseFloat(e.target.value) || 3;
                } else if (e.target.classList.contains('bg-checkbox')) {
                    assets[index].subtitleSettings.background = e.target.checked;
                }
            });
            
            assetsContainer.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-btn');
                if (removeBtn) {
                    const index = parseInt(removeBtn.dataset.index);
                    if (!isNaN(index)) removeClip(index);
                }
            });

            generateBtn.addEventListener('click', generateVideo);
            
            async function getVideoDuration(file) {
                return new Promise((resolve) => {
                    const video = document.createElement('video');
                    video.preload = 'metadata';
                    video.onloadedmetadata = () => { URL.revokeObjectURL(video.src); resolve(video.duration); };
                    video.src = URL.createObjectURL(file);
                });
            }
            
            function updateProgress(message, percentage) {
                statusMessage.textContent = message;
                progressBar.style.width = `${percentage}%`;
            }

            async function generateVideo() {
                if (!('VideoEncoder' in window)) {
                    statusMessage.textContent = 'エラー: お使いのブラウザはこのツールをサポートしていません。';
                    statusContainer.classList.remove('hidden');
                    return;
                }
                
                cancellationController = new AbortController();
                cancelBtn.onclick = () => cancellationController.abort();

                generateBtn.disabled = true;
                generateBtn.textContent = '処理中...';
                statusContainer.classList.remove('hidden');
                resultContainer.classList.add('hidden');
                updateProgress('準備中...', 0);

                try {
                    let totalDuration = assets.reduce((sum, a) => sum + a.duration, 0);
                    let muxer = new Muxer({
                        target: new ArrayBufferTarget(),
                        video: { codec: 'avc', width: VIDEO_WIDTH, height: VIDEO_HEIGHT },
                        audio: bgmFileInput.files[0] ? { codec: 'aac', sampleRate: 44100, numberOfChannels: 2 } : undefined,
                        fastStart: 'fragmented'
                    });

                    let videoEncoder = new VideoEncoder({
                        output: (chunk, meta) => muxer.addVideoChunk(chunk, meta), error: (e) => console.error(e)
                    });
                    videoEncoder.configure({ codec: 'avc1.42001f', width: VIDEO_WIDTH, height: VIDEO_HEIGHT, bitrate: 5_000_000, framerate: FPS });
                    
                    let audioEncoder, audioContext, bgmBuffer;
                    if (bgmFileInput.files[0]) {
                        updateProgress('BGMをデコード中...', 5);
                        audioContext = new AudioContext({ sampleRate: 44100 });
                        const bgmArrayBuffer = await bgmFileInput.files[0].arrayBuffer();
                        bgmBuffer = await audioContext.decodeAudioData(bgmArrayBuffer);
                        audioEncoder = new AudioEncoder({ output: (chunk, meta) => muxer.addAudioChunk(chunk, meta), error: (e) => console.error(e) });
                        audioEncoder.configure({ codec: 'mp4a.40.2', sampleRate: 44100, numberOfChannels: 2, bitrate: 128_000 });
                    }
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = VIDEO_WIDTH;
                    canvas.height = VIDEO_HEIGHT;
                    const ctx = canvas.getContext('2d');

                    updateProgress('クリップを準備中...', 10);
                    const assetData = await Promise.all(assets.map(async (asset) => {
                        if (cancellationController.signal.aborted) throw new DOMException('Aborted by user', 'AbortError');
                        if (asset.type === 'video') {
                           const videoEl = document.createElement('video');
                           videoEl.src = URL.createObjectURL(asset.file);
                           videoEl.muted = true;
                           await new Promise((resolve, reject) => { videoEl.onloadedmetadata = resolve; videoEl.onerror = reject; });
                           return { type: 'video', element: videoEl };
                        } else {
                            const bitmap = await createImageBitmap(asset.file);
                            return { type: 'image', element: bitmap };
                        }
                    }));

                    let frameCounter = 0;
                    let elapsed = 0;
                    updateProgress('フレームをレンダリング中...', 15);

                    for (let assetIndex = 0; assetIndex < assets.length; assetIndex++) {
                        const asset = assets[assetIndex];
                        const data = assetData[assetIndex];
                        const duration = asset.duration;
                        const totalFramesForAsset = Math.round(duration * FPS);

                        for (let frameIndex = 0; frameIndex < totalFramesForAsset; frameIndex++) {
                            if (cancellationController.signal.aborted) throw new DOMException('Aborted by user', 'AbortError');
                            const timeInCurrentAsset = frameIndex / FPS;
                            const timestamp = (frameCounter * 1_000_000) / FPS;

                            ctx.fillStyle = 'black';
                            ctx.fillRect(0, 0, VIDEO_WIDTH, VIDEO_HEIGHT);
                            
                            const el = data.element;
                            const elAspect = (el.videoWidth || el.width) / (el.videoHeight || el.height);
                            const canvasAspect = VIDEO_WIDTH / VIDEO_HEIGHT;
                            let dw, dh, dx, dy;
                            if (elAspect > canvasAspect) {
                                dh = VIDEO_HEIGHT; dw = dh * elAspect; dx = (VIDEO_WIDTH - dw) / 2; dy = 0;
                            } else {
                                dw = VIDEO_WIDTH; dh = dw / elAspect; dy = (VIDEO_HEIGHT - dh) / 2; dx = 0;
                            }

                            if (data.type === 'video') {
                                el.currentTime = timeInCurrentAsset;
                                await new Promise(r => { el.onseeked = r; if(el.readyState >= 3) r(); });
                                ctx.drawImage(el, dx, dy, dw, dh);
                            } else {
                                ctx.drawImage(el, dx, dy, dw, dh);
                            }

                            if (asset.subtitle) {
                                const settings = asset.subtitleSettings;
                                ctx.font = `bold ${settings.fontSize}px "Noto Sans JP", sans-serif`;
                                ctx.textAlign = 'center';
                                const yPosition = VIDEO_HEIGHT * (settings.position / 100);

                                if (settings.background) {
                                    const textMetrics = ctx.measureText(asset.subtitle);
                                    const textHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;
                                    ctx.fillStyle = 'rgba(80, 80, 80, 0.7)';
                                    ctx.fillRect(0, yPosition - textHeight * 1.2, VIDEO_WIDTH, textHeight * 1.6);
                                }
                                
                                ctx.fillStyle = 'white';
                                ctx.shadowColor = 'black';
                                ctx.shadowBlur = 10;
                                ctx.fillText(asset.subtitle, VIDEO_WIDTH / 2, yPosition);
                            }
                            
                            const frame = new VideoFrame(canvas, { timestamp });
                            videoEncoder.encode(frame);
                            frame.close();
                            
                            if (audioEncoder && bgmBuffer) {
                                const frameSamples = Math.round(bgmBuffer.sampleRate / FPS);
                                const audioStart = Math.floor(elapsed * bgmBuffer.sampleRate) + (frameIndex * frameSamples);
                                if (frameSamples > 0) {
                                    const audioData = new Float32Array(frameSamples * bgmBuffer.numberOfChannels);
                                    for (let c = 0; c < bgmBuffer.numberOfChannels; c++) {
                                        const channelData = bgmBuffer.getChannelData(c);
                                        for (let i = 0; i < frameSamples; i++) {
                                            audioData[i * bgmBuffer.numberOfChannels + c] = channelData[(audioStart + i) % channelData.length];
                                        }
                                    }
                                    const audioFrame = new AudioData({
                                        format: 'f32', sampleRate: bgmBuffer.sampleRate, numberOfFrames: frameSamples,
                                        numberOfChannels: bgmBuffer.numberOfChannels, timestamp: timestamp, data: audioData,
                                    });
                                    audioEncoder.encode(audioFrame);
                                    audioFrame.close();
                                }
                            }
                            frameCounter++;
                        }
                        elapsed += duration;
                        updateProgress(`レンダリング中...`, 15 + 80 * (elapsed / totalDuration));
                    }
                    
                    updateProgress('最終処理中...', 95);
                    await videoEncoder.flush();
                    if (audioEncoder) await audioEncoder.flush();
                    muxer.finalize();
                    
                    const { buffer } = muxer.target;
                    const blob = new Blob([buffer], { type: 'video/mp4' });
                    const url = URL.createObjectURL(blob);

                    resultVideo.src = url;
                    downloadLink.href = url;
                    downloadLink.download = `reels-video-${Date.now()}.mp4`;
                    statusContainer.classList.add('hidden');
                    resultContainer.classList.remove('hidden');

                } catch (err) {
                    if (err.name === 'AbortError') {
                        statusMessage.textContent = '生成が中止されました。';
                        console.log('Video generation cancelled by user.');
                    } else {
                        console.error("動画生成中にエラーが発生しました:", err);
                        statusMessage.textContent = `エラーが発生しました: ${err.message}`;
                        progressBar.style.backgroundColor = 'red';
                    }
                } finally {
                    generateBtn.disabled = false;
                    generateBtn.textContent = '動画を生成する';
                    setTimeout(() => { // 少し待ってから非表示にする
                         if (statusMessage.textContent === '生成が中止されました。') {
                            statusContainer.classList.add('hidden');
                         }
                    }, 2000);
                }
            }
            addNewClip();
        }
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>
</html>
